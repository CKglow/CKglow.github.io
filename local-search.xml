<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>易拉宝展示</title>
    <link href="/2025/02/03/%E6%98%93%E6%8B%89%E5%AE%9D%E5%B1%95%E7%A4%BA/"/>
    <url>/2025/02/03/%E6%98%93%E6%8B%89%E5%AE%9D%E5%B1%95%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="易拉宝展示"><a href="#易拉宝展示" class="headerlink" title="易拉宝展示"></a>易拉宝展示</h1><p>以下是个人的全部易拉宝作品展示<br>随缘接单<br>欢迎扩列 QQ：1439429910<br><img src="https://alist.ckxtm.com/d/AliDrive/img/%E7%9F%A5%E7%A4%BC%E6%98%93%E6%8B%89%E5%AE%9D80180100.jpg" alt="知礼易拉宝241229"></p><p><img src="https://alist.ckxtm.com/d/AliDrive/img/0111%E7%9F%A5%E7%A4%BC%E6%98%93%E6%8B%89%E5%AE%9D2.3.jpg" alt="知礼易拉宝250111"></p><p><img src="https://alist.ckxtm.com/d/AliDrive/img/0209%E9%B8%AD%E9%B8%AD%E6%98%93%E6%8B%89%E5%AE%9D1.2.jpg" alt="鸭鸭易拉宝250209"></p>]]></content>
    
    
    <categories>
      
      <category>idol</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ps</tag>
      
      <tag>idol</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPIO学习</title>
    <link href="/2025/02/03/GPIO%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/03/GPIO%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="GPIO-红外探测"><a href="#GPIO-红外探测" class="headerlink" title="GPIO | 红外探测"></a>GPIO | 红外探测</h1><h1 id="GPIO-红外探测-1"><a href="#GPIO-红外探测-1" class="headerlink" title="GPIO | 红外探测"></a>GPIO | 红外探测</h1><p>小车的循迹功能就是通过4路红外探测黑线来实现的</p><h2 id="GPIO-简介"><a href="#GPIO-简介" class="headerlink" title="GPIO 简介"></a>GPIO 简介</h2><p>GPIO就是从STM32芯片上引出的引脚，可以通过拉高&#x2F;拉低电平等方式简单粗暴地控制，也可以使用TIM、UART等系统资源控制，也可以检测GPIO端口电平的高低来实现数据输入。</p><h2 id="GPIO输出–以点亮LED为例"><a href="#GPIO输出–以点亮LED为例" class="headerlink" title="GPIO输出–以点亮LED为例"></a>GPIO输出–以点亮LED为例</h2><h3 id="编程顺序"><a href="#编程顺序" class="headerlink" title="编程顺序"></a>编程顺序</h3><ol><li>使能GPIO端口时钟</li><li>初始化GPIO引脚</li><li>控制GPIO输出高、低电平</li></ol><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="1-在-h文件中列出需要的GPIO的宏"><a href="#1-在-h文件中列出需要的GPIO的宏" class="headerlink" title="1.在.h文件中列出需要的GPIO的宏"></a>1.在.h文件中列出需要的GPIO的宏</h4><p>编程时使用宏定义便于提高程序的可移植性<br>每个.h文件都include这个头文件<br><code>#include &quot;stm32f10x.h&quot;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义LED连接的GPIO端口, 用户只需要修改下面的代码即可改变控制的LED引脚 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO_PORT    GPIOC              <span class="hljs-comment">/* GPIO端口 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO_CLK     RCC_APB2Periph_GPIOC<span class="hljs-comment">/* GPIO端口时钟 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO_PINGPIO_Pin_2        <span class="hljs-comment">/*LED1在C2上*/</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_GPIO_PORT    GPIOC              <span class="hljs-comment">/* GPIO端口 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_GPIO_CLK     RCC_APB2Periph_GPIOC<span class="hljs-comment">/* GPIO端口时钟 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_GPIO_PINGPIO_Pin_3        <span class="hljs-comment">/*LED2在C3上*/</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*两种控制GPIO电平的宏定义方法*/</span><br><br><span class="hljs-comment">/* 使用标准的固件库控制IO*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1(a)<span class="hljs-keyword">if</span> (a)\</span><br><span class="hljs-meta">GPIO_SetBits(LED1_GPIO_PORT,LED1_GPIO_PIN);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span>\</span><br><span class="hljs-meta">GPIO_ResetBits(LED1_GPIO_PORT,LED1_GPIO_PIN)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2(a)<span class="hljs-keyword">if</span> (a)\</span><br><span class="hljs-meta">GPIO_SetBits(LED2_GPIO_PORT,LED2_GPIO_PIN);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span>\</span><br><span class="hljs-meta">GPIO_ResetBits(LED2_GPIO_PORT,LED2_GPIO_PIN)</span><br><span class="hljs-comment">//SetBits为高电平，ResetBits为低电平</span><br><br><br><br><span class="hljs-comment">/* 直接操作寄存器的方法控制IO */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>digitalHi(p,i) &#123;p-&gt;BSRR=i;&#125; <span class="hljs-comment">//输出为高电平</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> digitalLo(p,i) &#123;p-&gt;BRR=i;&#125; <span class="hljs-comment">//输出低电平</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> digitalToggle(p,i) &#123;p-&gt;ODR ^=i;&#125; <span class="hljs-comment">//输出反转状态</span></span><br><br><br><span class="hljs-comment">/* 定义控制IO的宏 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_TOGGLE digitalToggle(LED1_GPIO_PORT,LED1_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_HI   digitalHi(LED1_GPIO_PORT,LED1_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_LO   digitalLo(LED1_GPIO_PORT,LED1_GPIO_PIN)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_TOGGLE digitalToggle(LED2_GPIO_PORT,LED2_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_HI   digitalHi(LED2_GPIO_PORT,LED2_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_LO   digitalLo(LED2_GPIO_PORT,LED2_GPIO_PIN)</span><br><span class="hljs-comment">//在实际使用中也可以根据开发板LED实际亮灭所需电平情况定义为LED1_ON.LED1_OFF</span><br></code></pre></td></tr></table></figure><h4 id="2-在-c文件中编写GPIO初始化函数"><a href="#2-在-c文件中编写GPIO初始化函数" class="headerlink" title="2.在.c文件中编写GPIO初始化函数"></a>2.在.c文件中编写GPIO初始化函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LED_GPIO_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*定义一个GPIO_InitTypeDef类型的结构体*/</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br><br><span class="hljs-comment">/*开启LED相关的GPIO外设时钟*/</span><br>RCC_APB2PeriphClockCmd( LED1_GPIO_CLK | LED2_GPIO_CLK , ENABLE);<br><span class="hljs-comment">/*选择要控制的GPIO引脚*/</span><br>GPIO_InitStructure.GPIO_Pin = LED1_GPIO_PIN;<br><br><span class="hljs-comment">/*设置引脚模式为通用推挽输出*/</span><br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   <br><br><span class="hljs-comment">/*设置引脚速率为50MHz */</span>   <br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <br><br><span class="hljs-comment">/*调用库函数，初始化GPIO*/</span><br>GPIO_Init(LED1_GPIO_PORT, &amp;GPIO_InitStructure);<br><br><span class="hljs-comment">/*选择要控制的GPIO引脚*/</span><br>GPIO_InitStructure.GPIO_Pin = LED2_GPIO_PIN;<br><br><span class="hljs-comment">/*调用库函数，初始化GPIO*/</span><br>GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_InitStructure);<br><br><br><span class="hljs-comment">/* 关闭所有led灯*/</span><br>GPIO_SetBits(LED1_GPIO_PORT, LED1_GPIO_PIN);<br><br><span class="hljs-comment">/* 关闭所有led灯*/</span><br>GPIO_SetBits(LED2_GPIO_PORT, LED2_GPIO_PIN);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个初始化函数是利用库文件写的，首先要打开GPIO端口的时钟，然后向GPIO_InitTypeDef结构体里填入想要配置的相关信息，最后用GPIO_Init()完成配置</p><h4 id="3-GPIO端口的8种工作模式"><a href="#3-GPIO端口的8种工作模式" class="headerlink" title="3.GPIO端口的8种工作模式"></a>3.GPIO端口的8种工作模式</h4><p>1、4种输入模式</p><p>（1）GPIO_Mode_IN_FLOATING 浮空输入<br>（2）GPIO_Mode_IPU 上拉输入<br>（3）GPIO_Mode_IPD 下拉输入<br>（4）GPIO_Mode_AIN 模拟输入</p><p>2、4种输出模式</p><p>（5）GPIO_Mode_Out_OD 开漏输出（带上拉或者下拉）<br>（6）GPIO_Mode_AF_OD 复用开漏输出（带上拉或者下拉）<br>（7）GPIO_Mode_Out_PP 推挽输出（带上拉或者下拉）<br>（8）GPIO_Mode_AF_PP 复用推挽输出（带上拉或者下拉）</p><p>最常用的就是前三种输入模式（根据外设实际情况而定），和复用推挽输出，速度多选50MHZ和10MHZ</p><h2 id="GPIO输入-以红外探测为例"><a href="#GPIO输入-以红外探测为例" class="headerlink" title="GPIO输入 以红外探测为例"></a>GPIO输入 以红外探测为例</h2><h3 id="红外探测器的使用方"><a href="#红外探测器的使用方" class="headerlink" title="红外探测器的使用方"></a>红外探测器的使用方</h3><p>小车的循迹功能就是通过4路红外探测黑线来实现的</p><h2 id="GPIO-简介-1"><a href="#GPIO-简介-1" class="headerlink" title="GPIO 简介"></a>GPIO 简介</h2><p>GPIO就是从STM32芯片上引出的引脚，可以通过拉高&#x2F;拉低电平等方式简单粗暴地控制，也可以使用TIM、UART等系统资源控制，也可以检测GPIO端口电平的高低来实现数据输入。</p><h2 id="GPIO输出–以点亮LED为例-1"><a href="#GPIO输出–以点亮LED为例-1" class="headerlink" title="GPIO输出–以点亮LED为例"></a>GPIO输出–以点亮LED为例</h2><h3 id="编程顺序-1"><a href="#编程顺序-1" class="headerlink" title="编程顺序"></a>编程顺序</h3><ol><li>使能GPIO端口时钟</li><li>初始化GPIO引脚</li><li>控制GPIO输出高、低电平</li></ol><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="1-在-h文件中列出需要的GPIO的宏-1"><a href="#1-在-h文件中列出需要的GPIO的宏-1" class="headerlink" title="1.在.h文件中列出需要的GPIO的宏"></a>1.在.h文件中列出需要的GPIO的宏</h4><p>编程时使用宏定义便于提高程序的可移植性<br>每个.h文件都include这个头文件<br><code>#include &quot;stm32f10x.h&quot;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 定义LED连接的GPIO端口, 用户只需要修改下面的代码即可改变控制的LED引脚 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO_PORT    GPIOC              <span class="hljs-comment">/* GPIO端口 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO_CLK     RCC_APB2Periph_GPIOC<span class="hljs-comment">/* GPIO端口时钟 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_GPIO_PINGPIO_Pin_2        <span class="hljs-comment">/*LED1在C2上*/</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_GPIO_PORT    GPIOC              <span class="hljs-comment">/* GPIO端口 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_GPIO_CLK     RCC_APB2Periph_GPIOC<span class="hljs-comment">/* GPIO端口时钟 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_GPIO_PINGPIO_Pin_3        <span class="hljs-comment">/*LED2在C3上*/</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*两种控制GPIO电平的宏定义方法*/</span><br><br><span class="hljs-comment">/* 使用标准的固件库控制IO*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1(a)<span class="hljs-keyword">if</span> (a)\</span><br><span class="hljs-meta">GPIO_SetBits(LED1_GPIO_PORT,LED1_GPIO_PIN);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span>\</span><br><span class="hljs-meta">GPIO_ResetBits(LED1_GPIO_PORT,LED1_GPIO_PIN)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2(a)<span class="hljs-keyword">if</span> (a)\</span><br><span class="hljs-meta">GPIO_SetBits(LED2_GPIO_PORT,LED2_GPIO_PIN);\</span><br><span class="hljs-meta"><span class="hljs-keyword">else</span>\</span><br><span class="hljs-meta">GPIO_ResetBits(LED2_GPIO_PORT,LED2_GPIO_PIN)</span><br><span class="hljs-comment">//SetBits为高电平，ResetBits为低电平</span><br><br><br><br><span class="hljs-comment">/* 直接操作寄存器的方法控制IO */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>digitalHi(p,i) &#123;p-&gt;BSRR=i;&#125; <span class="hljs-comment">//输出为高电平</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> digitalLo(p,i) &#123;p-&gt;BRR=i;&#125; <span class="hljs-comment">//输出低电平</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> digitalToggle(p,i) &#123;p-&gt;ODR ^=i;&#125; <span class="hljs-comment">//输出反转状态</span></span><br><br><br><span class="hljs-comment">/* 定义控制IO的宏 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_TOGGLE digitalToggle(LED1_GPIO_PORT,LED1_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_HI   digitalHi(LED1_GPIO_PORT,LED1_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED1_LO   digitalLo(LED1_GPIO_PORT,LED1_GPIO_PIN)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_TOGGLE digitalToggle(LED2_GPIO_PORT,LED2_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_HI   digitalHi(LED2_GPIO_PORT,LED2_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LED2_LO   digitalLo(LED2_GPIO_PORT,LED2_GPIO_PIN)</span><br><span class="hljs-comment">//在实际使用中也可以根据开发板LED实际亮灭所需电平情况定义为LED1_ON.LED1_OFF</span><br></code></pre></td></tr></table></figure><h4 id="2-在-c文件中编写GPIO初始化函数-1"><a href="#2-在-c文件中编写GPIO初始化函数-1" class="headerlink" title="2.在.c文件中编写GPIO初始化函数"></a>2.在.c文件中编写GPIO初始化函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LED_GPIO_Config</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*定义一个GPIO_InitTypeDef类型的结构体*/</span><br>GPIO_InitTypeDef GPIO_InitStructure;<br><br><span class="hljs-comment">/*开启LED相关的GPIO外设时钟*/</span><br>RCC_APB2PeriphClockCmd( LED1_GPIO_CLK | LED2_GPIO_CLK , ENABLE);<br><span class="hljs-comment">/*选择要控制的GPIO引脚*/</span><br>GPIO_InitStructure.GPIO_Pin = LED1_GPIO_PIN;<br><br><span class="hljs-comment">/*设置引脚模式为通用推挽输出*/</span><br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   <br><br><span class="hljs-comment">/*设置引脚速率为50MHz */</span>   <br>GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; <br><br><span class="hljs-comment">/*调用库函数，初始化GPIO*/</span><br>GPIO_Init(LED1_GPIO_PORT, &amp;GPIO_InitStructure);<br><br><span class="hljs-comment">/*选择要控制的GPIO引脚*/</span><br>GPIO_InitStructure.GPIO_Pin = LED2_GPIO_PIN;<br><br><span class="hljs-comment">/*调用库函数，初始化GPIO*/</span><br>GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_InitStructure);<br><br><br><span class="hljs-comment">/* 关闭所有led灯*/</span><br>GPIO_SetBits(LED1_GPIO_PORT, LED1_GPIO_PIN);<br><br><span class="hljs-comment">/* 关闭所有led灯*/</span><br>GPIO_SetBits(LED2_GPIO_PORT, LED2_GPIO_PIN);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个初始化函数是利用库文件写的，首先要打开GPIO端口的时钟，然后向GPIO_InitTypeDef结构体里填入想要配置的相关信息，最后用GPIO_Init()完成配置</p><h4 id="3-GPIO端口的8种工作模式-1"><a href="#3-GPIO端口的8种工作模式-1" class="headerlink" title="3.GPIO端口的8种工作模式"></a>3.GPIO端口的8种工作模式</h4><p>1、4种输入模式</p><p>（1）GPIO_Mode_IN_FLOATING 浮空输入<br>（2）GPIO_Mode_IPU 上拉输入<br>（3）GPIO_Mode_IPD 下拉输入<br>（4）GPIO_Mode_AIN 模拟输入</p><p>2、4种输出模式</p><p>（5）GPIO_Mode_Out_OD 开漏输出（带上拉或者下拉）<br>（6）GPIO_Mode_AF_OD 复用开漏输出（带上拉或者下拉）<br>（7）GPIO_Mode_Out_PP 推挽输出（带上拉或者下拉）<br>（8）GPIO_Mode_AF_PP 复用推挽输出（带上拉或者下拉）</p><p>最常用的就是前三种输入模式（根据外设实际情况而定），和复用推挽输出，速度多选50MHZ和10MHZ</p><h2 id="GPIO输入-以红外探测为例-1"><a href="#GPIO输入-以红外探测为例-1" class="headerlink" title="GPIO输入 以红外探测为例"></a>GPIO输入 以红外探测为例</h2><h3 id="红外传感器使用方法"><a href="#红外传感器使用方法" class="headerlink" title="红外传感器使用方法"></a>红外传感器使用方法</h3><p>通过查阅使用说明或者淘宝详情得知，当灵敏度调整正确时，在白色处输出低电平，LED亮；在黑色处输出高电平，LED灭。所以设计程序应该设置GPIO为上拉输入或浮空输入，即当探测到黑线时产生输入。这里我选择上拉输入，因为上拉输入更适合调整输入后产生的动作对应的延迟。</p><p>另外使用 GPIO_ReadInputDataBit(GPIOx_PORT,GPIOx_PIN) 来读取上拉输入。</p><p>XUNJI.h 里面的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//IN 1 2 3 4 - A12 A2 A4 A5</span><br><span class="hljs-comment">//循迹5就是前面壁障的红外探头</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI1_GPIO_CLK     RCC_APB2Periph_GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI1_GPIO_PORT    GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI1_GPIO_PIN     GPIO_Pin_12</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI2_GPIO_CLK     RCC_APB2Periph_GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI2_GPIO_PORT    GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI2_GPIO_PIN     GPIO_Pin_2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI3_GPIO_CLK     RCC_APB2Periph_GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI3_GPIO_PORT    GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI3_GPIO_PIN     GPIO_Pin_4</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI4_GPIO_CLK     RCC_APB2Periph_GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI4_GPIO_PORT    GPIOA</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI4_GPIO_PIN     GPIO_Pin_5</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI5_GPIO_CLK     RCC_APB2Periph_GPIOC</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI5_GPIO_PORT    GPIOC</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> XUNJI5_GPIO_PIN     GPIO_Pin_0</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R1 GPIO_ReadInputDataBit(XUNJI1_GPIO_PORT,XUNJI1_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R2 GPIO_ReadInputDataBit(XUNJI2_GPIO_PORT,XUNJI2_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> L2 GPIO_ReadInputDataBit(XUNJI3_GPIO_PORT,XUNJI3_GPIO_PIN)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> L1 GPIO_ReadInputDataBit(XUNJI4_GPIO_PORT,XUNJI4_GPIO_PIN) <span class="hljs-comment">// L1 L2 R2 R1 </span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F1 GPIO_ReadInputDataBit(XUNJI5_GPIO_PORT,XUNJI5_GPIO_PIN)</span><br></code></pre></td></tr></table></figure><p>配置XUNJI.c，初始化GPIO端口，写读取GPIO输入函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">xunji_Init</span><span class="hljs-params">()</span><br>&#123;<br>  GPIO_InitTypeDef GPIO_InitStructure;<br><br>  RCC_APB2PeriphClockCmd( XUNJI1_GPIO_CLK, ENABLE); <br>  GPIO_InitStructure.GPIO_Pin =  XUNJI1_GPIO_PIN|XUNJI2_GPIO_PIN|XUNJI3_GPIO_PIN|XUNJI4_GPIO_PIN;<br>  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<span class="hljs-comment">//上拉输入</span><br>  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>  GPIO_Init(XUNJI1_GPIO_PORT , &amp;GPIO_InitStructure); <br><br>RCC_APB2PeriphClockCmd( XUNJI5_GPIO_CLK, ENABLE); <br>  GPIO_InitStructure.GPIO_Pin =  XUNJI5_GPIO_PIN;<br>  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<span class="hljs-comment">//上拉输入</span><br>  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>  GPIO_Init(XUNJI5_GPIO_PORT , &amp;GPIO_InitStructure); <br><br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Read_xunji_Date</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br> L1;<br>L2;<br>R2;<br>R1;<br>F1;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 main.c 中，可以用循环和if语句来读取红外传感器的值并作出指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>Read_xunji_Date();<br><span class="hljs-keyword">if</span>(L1==<span class="hljs-number">0</span>&amp;&amp;L2==<span class="hljs-number">1</span>&amp;&amp;R2==<span class="hljs-number">1</span>&amp;&amp;R1==<span class="hljs-number">0</span>)<span class="hljs-comment">//1为探测到黑线，0为白线</span><br>  &#123;<br>  Go();  <br>  delay_ms(<span class="hljs-number">100</span>);<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>具体的循迹指令可以参考源文件</p><p>但是主要是要理解循迹的逻辑，具体的代码还要根据实际跑道进行优化</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>code</tag>
      
      <tag>hardware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MetroMap</title>
    <link href="/2025/02/03/MetroMap/"/>
    <url>/2025/02/03/MetroMap/</url>
    
    <content type="html"><![CDATA[<h1 id="怎样画一张地铁图-Ai"><a href="#怎样画一张地铁图-Ai" class="headerlink" title="怎样画一张地铁图 | Ai"></a>怎样画一张地铁图 | Ai</h1><p>1.使用钢笔工具，点击创建锚点后，按住 shift 移动光标（shift使光标只能水平、垂直、45°移动），继续创建锚点画出线路基本走向</p><p>2.调整描边颜色、端点和转角为圆滑</p><p>3.在 fx - 风格化 - 圆角 中选择线路转弯处圆角半径</p><p>4.使用椭圆工具，按住 shift 画出正圆，作为地铁站图标</p><p>5.搭配使用多边形工具、钢笔工具、曲率工具画出不规则图标</p><p>6.添加一点创意</p><p>7.导出时选择全画布导出</p><p>附上：城市天际线架空城市轨道交通图</p><p><img src="https://alist.ckxtm.com/d/AliDrive/img/%E6%B1%9F%E9%98%B3%E5%9C%B0%E9%93%81%E4%BA%8C%E6%9C%9F%E7%BA%BF%E8%B7%AF%E5%9B%BE2%20-%20%E5%89%AF%E6%9C%AC.png" alt="MetroMap"></p>]]></content>
    
    
    <categories>
      
      <category>skill</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ai</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
